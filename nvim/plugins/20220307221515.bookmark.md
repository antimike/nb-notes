# splitjoin.vim/splitjoin.txt at master · AndrewRadev/splitjoin.vim · GitHub (github.com)

<https://github.com/AndrewRadev/splitjoin.vim/blob/master/doc/splitjoin.txt>

## Description

Switch between single-line and multiline forms of code - splitjoin.vim/splitjoin.txt at master · AndrewRadev/splitjoin.vim

## Tags

#configure

## Content

[Skip to content](#start-of-content){.px-2 .py-4 .color-bg-accent-emphasis .color-fg-on-emphasis .show-on-focus .js-skip-to-content}

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo){.d-inline-block .d-lg-none .f5 .no-underline .border .color-border-default .rounded-2 .px-2 .py-1 .mr-3 .mr-sm-5 .color-fg-inherit}

-   Product
    -   [Features](/features){.lh-condensed-ultra .d-block .no-underline .position-relative .Link--primary .text-bold .py-2}
    -   [Mobile](/mobile){.lh-condensed-ultra .d-block .no-underline .position-relative .Link--secondary .py-2}
    -   [Actions](/features/actions){.lh-condensed-ultra .d-block .no-underline .position-relative .Link--secondary .py-2}
    -   [Codespaces](/features/codespaces){.lh-condensed-ultra .d-block .no-underline .position-relative .Link--secondary .py-2}
    -   [Packages](/features/packages){.lh-condensed-ultra .d-block .no-underline .position-relative .Link--secondary .py-2}
    -   [Security](/features/security){.lh-condensed-ultra .d-block .no-underline .position-relative .Link--secondary .py-2}
    -   [Code review](/features/code-review){.lh-condensed-ultra .d-block .no-underline .position-relative .Link--secondary .py-2}
    -   [Issues](/features/issues){.lh-condensed-ultra .d-block .no-underline .position-relative .Link--secondary .py-2}
    -   [Integrations](/features/integrations){.lh-condensed-ultra .d-block .no-underline .position-relative .Link--secondary .py-2}
    -   [GitHub Sponsors](/sponsors){.lh-condensed-ultra .d-block .no-underline .position-relative .Link--primary .text-bold .border-top .pt-4 .pb-2 .mt-3}
    -   [Customer stories](/customer-stories){.lh-condensed-ultra .d-block .no-underline .position-relative .Link--primary .text-bold .py-2}
-   [Team](/team){.HeaderMenu-link .no-underline .py-3 .d-block .d-lg-inline-block}
-   [Enterprise](/enterprise){.HeaderMenu-link .no-underline .py-3 .d-block .d-lg-inline-block}
-   Explore
    -   [Explore GitHub](/explore){.lh-condensed-ultra .d-block .no-underline .position-relative .Link--primary .text-bold .py-2}
    -   Learn and contribute
    -   [Topics](/topics){.lh-condensed-ultra .d-block .no-underline .position-relative .Link--secondary .py-2}
    -   [Collections](/collections){.lh-condensed-ultra .d-block .no-underline .position-relative .Link--secondary .py-2}
    -   [Trending](/trending){.lh-condensed-ultra .d-block .no-underline .position-relative .Link--secondary .py-2}
    -   [Learning Lab](https://lab.github.com/){.lh-condensed-ultra .d-block .no-underline .position-relative .Link--secondary .py-2}
    -   [Open source guides](https://opensource.guide){.lh-condensed-ultra .d-block .no-underline .position-relative .Link--secondary .py-2}
    -   Connect with others
    -   [The ReadME Project](/readme){.lh-condensed-ultra .d-block .no-underline .position-relative .Link--secondary .py-2}
    -   [Events](/events){.lh-condensed-ultra .d-block .no-underline .position-relative .Link--secondary .py-2}
    -   [Community forum](https://github.community){.lh-condensed-ultra .d-block .no-underline .position-relative .Link--secondary .py-2}
    -   [GitHub Education](https://education.github.com){.lh-condensed-ultra .d-block .no-underline .position-relative .Link--secondary .py-2}
    -   [GitHub Stars program](https://stars.github.com){.lh-condensed-ultra .d-block .no-underline .position-relative .Link--secondary .py-2}
-   [Marketplace](/marketplace){.HeaderMenu-link .no-underline .py-3 .d-block .d-lg-inline-block}
-   Pricing
    -   [Plans](/pricing){.lh-condensed-ultra .d-block .no-underline .position-relative .Link--primary .text-bold .py-2}
    -   [Compare plans](/pricing#compare-features){.lh-condensed-ultra .d-block .no-underline .position-relative .Link--secondary .py-2}
    -   [Contact Sales](https://github.com/enterprise/contact){.lh-condensed-ultra .d-block .no-underline .position-relative .Link--secondary .py-2}
    -   [Education](https://education.github.com){.lh-condensed-ultra .d-block .no-underline .position-relative .Link--primary .text-bold .border-top .pt-4 .pb-2 .mt-3}

```{=html}
<!-- -->
```
-   [](){.no-underline .d-flex .flex-auto .flex-items-center .jump-to-suggestions-path .js-jump-to-suggestion-path .js-navigation-open .p-2}
    ![](){.avatar .mr-2 .flex-shrink-0 .js-jump-to-suggestion-avatar .d-none width="28" height="28"}
    In this repository
    All GitHub
    ↵
    Jump to
    ↵

```{=html}
<!-- -->
```
-   No suggested jump to results

```{=html}
<!-- -->
```
-   [](){.no-underline .d-flex .flex-auto .flex-items-center .jump-to-suggestions-path .js-jump-to-suggestion-path .js-navigation-open .p-2}
    ![](){.avatar .mr-2 .flex-shrink-0 .js-jump-to-suggestion-avatar .d-none width="28" height="28"}
    In this repository
    All GitHub
    ↵
    Jump to
    ↵
-   [](){.no-underline .d-flex .flex-auto .flex-items-center .jump-to-suggestions-path .js-jump-to-suggestion-path .js-navigation-open .p-2}
    ![](){.avatar .mr-2 .flex-shrink-0 .js-jump-to-suggestion-avatar .d-none width="28" height="28"}
    In this user
    All GitHub
    ↵
    Jump to
    ↵
-   [](){.no-underline .d-flex .flex-auto .flex-items-center .jump-to-suggestions-path .js-jump-to-suggestion-path .js-navigation-open .p-2}
    ![](){.avatar .mr-2 .flex-shrink-0 .js-jump-to-suggestion-avatar .d-none width="28" height="28"}
    In this repository
    All GitHub
    ↵
    Jump to
    ↵

[Sign in](/login?return_to=https%3A%2F%2Fgithub.com%2FAndrewRadev%2Fsplitjoin.vim%2Fblob%2Fmaster%2Fdoc%2Fsplitjoin.txt){.HeaderMenu-link .flex-shrink-0 .no-underline}

[Sign up](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Fblob%2Fshow&source=header-repo&source_repo=AndrewRadev%2Fsplitjoin.vim){.HeaderMenu-link .flex-shrink-0 .d-inline-block .no-underline .border .color-border-default .rounded .px-2 .py-1}

{{ message }}

[AndrewRadev](/AndrewRadev){.url .fn} / **[splitjoin.vim](/AndrewRadev/splitjoin.vim)** Public {#andrewradev-splitjoin.vim-public .d-flex .flex-wrap .flex-items-center .wb-break-word .f3 .text-normal}
==============================================================================================

-   Notifications
-   Fork
    81
-   Star
    1.6k

```{=html}
<!-- -->
```
-   Code
-   Issues
    15
-   Pull requests
    1
-   Actions
-   Projects
    0
-   Wiki
-   Security
-   Insights

More

-   [Code](/AndrewRadev/splitjoin.vim/tree/master){.js-selected-navigation-item .selected .dropdown-item}
-   [Issues](/AndrewRadev/splitjoin.vim/issues){.js-selected-navigation-item .dropdown-item}
-   [Pull requests](/AndrewRadev/splitjoin.vim/pulls){.js-selected-navigation-item .dropdown-item}
-   [Actions](/AndrewRadev/splitjoin.vim/actions){.js-selected-navigation-item .dropdown-item}
-   [Projects](/AndrewRadev/splitjoin.vim/projects?type=beta){.js-selected-navigation-item .dropdown-item}
-   [Wiki](/AndrewRadev/splitjoin.vim/wiki){.js-selected-navigation-item .dropdown-item}
-   [Security](/AndrewRadev/splitjoin.vim/security){.js-selected-navigation-item .dropdown-item}
-   [Insights](/AndrewRadev/splitjoin.vim/pulse){.js-selected-navigation-item .dropdown-item}

[Permalink](/AndrewRadev/splitjoin.vim/blob/452d1359fb14731a316be49fb446a05d2c7d2f71/doc/splitjoin.txt){.d-none .js-permalink-shortcut}

master

Switch branches/tags

Branches

Tags

Could not load branches

Nothing to show

{{ refName }}
default

[View all branches](/AndrewRadev/splitjoin.vim/branches)

Could not load tags

Nothing to show

{{ refName }}
default

[View all tags](/AndrewRadev/splitjoin.vim/tags)

[splitjoin.vim](/AndrewRadev/splitjoin.vim/tree/master)/[doc](/AndrewRadev/splitjoin.vim/tree/master/doc)/**splitjoin.txt** {#blob-path .breadcrumb .flex-auto .flex-self-center .min-width-0 .text-normal .mx-2 .width-full .width-md-auto .flex-order-1 .flex-md-order-none .mt-3 .mt-md-0}
---------------------------------------------------------------------------------------------------------------------------

[Go to file](/AndrewRadev/splitjoin.vim/find/master){.js-pjax-capture-input .btn .mr-2 .d-none .d-md-block}

-   [Go to file
    T](/AndrewRadev/splitjoin.vim/find/master){.dropdown-item .d-flex .flex-items-baseline}
-   Go to line
    L
-   
-   Copy path
-   Copy permalink

This commit does not belong to any branch on this repository, and may belong to a fork outside of the repository.

 

 

Cannot retrieve contributors at this time

1954 lines (1625 sloc)
49.6 KB

[Raw](/AndrewRadev/splitjoin.vim/raw/master/doc/splitjoin.txt){#raw-url .js-permalink-replaceable-link .btn-sm .btn .BtnGroup-item}
[Blame](/AndrewRadev/splitjoin.vim/blame/master/doc/splitjoin.txt){.js-update-url-with-hash .js-permalink-replaceable-link .btn-sm .btn .BtnGroup-item}

-   [Open with Desktop](https://desktop.github.com){.dropdown-item .tooltipped .tooltipped-nw .js-remove-unless-platform}
-   [View raw](/AndrewRadev/splitjoin.vim/raw/master/doc/splitjoin.txt){.dropdown-item}
-   
-   [View blame](/AndrewRadev/splitjoin.vim/blame/master/doc/splitjoin.txt){.dropdown-item}

This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
[Learn more about bidirectional Unicode characters](https://github.co/hiddenchars)

[Show hidden characters](%7B%7B%20revealButtonHref%20%7D%7D){.btn-sm .btn}

  -- -----------------------------------------------------------------------------------------------------
     \*splitjoin.txt\* Switch between single-line and multiline forms of code
     
     ==============================================================================
     CONTENTS \*splitjoin\* \*splitjoin-contents\*
     
     Installation\...\...\...\...\...\...\...\...\...: \|splitjoin-installation\|
     Usage\...\...\...\...\...\...\...\...\...\...\....: \|splitjoin-usage\|
     
     C\...\...\...\...\...\...\...\...\...\...\...\.....: \|splitjoin-c\|
     Coffeescript\...\...\...\...\...\...\...\...\...: \|splitjoin-coffee\|
     CSS\...\...\...\...\...\...\...\...\...\...\...\...: \|splitjoin-css\|
     Elixir\...\...\...\...\...\...\...\...\...\...\...: \|splitjoin-elixir\|
     Elm\...\...\...\...\...\...\...\...\...\...\.... : \|splitjoin-elm\|
     Eruby\...\...\...\...\...\...\...\...\...\...\....: \|splitjoin-eruby\|
     Go\...\...\...\...\...\...\...\...\...\...\...\....: \|splitjoin-go\|
     HAML\...\...\...\...\...\...\...\...\...\...\.....: \|splitjoin-haml\|
     Handlebars\...\...\...\...\...\...\...\...\.....: \|splitjoin-handlebars\|
     HTML\...\...\...\...\...\...\...\...\...\...\.....: \|splitjoin-html\|
     Java\...\...\...\...\...\...\...\...\...\...\.....: \|splitjoin-java\|
     Javascript\...\...\...\...\...\...\...\...\.....: \|splitjoin-javascript\| \|splitjoin-json\|
     JSX/TSX\...\...\...\...\...\...\...\...\...\.....: \|splitjoin-jsx\| \|splitjoin-tsx\|
     Lua\...\...\...\...\...\...\...\...\...\...\...\...: \|splitjoin-lua\|
     Perl\...\...\...\...\...\...\...\...\...\...\.....: \|splitjoin-perl\|
     PHP\...\...\...\...\...\...\...\...\...\...\...\...: \|splitjoin-php\|
     Python\...\...\...\...\...\...\...\...\...\...\...: \|splitjoin-python\|
     R\...\...\...\...\...\...\...\...\...\...\...\.....: \|splitjoin-r\|
     Ruby\...\...\...\...\...\...\...\...\...\...\.....: \|splitjoin-ruby\|
     Rust\...\...\...\...\...\...\...\...\...\...\.....: \|splitjoin-rust\|
     SCSS/Less\...\...\...\...\...\...\...\...\...\...: \|splitjoin-scss\| \|splitjoin-less\|
     Shell\...\...\...\...\...\...\...\...\...\...\....: \|splitjoin-shell\|
     TeX\...\...\...\...\...\...\...\...\...\...\...\...: \|splitjoin-tex\|
     Vimscript\...\...\...\...\...\...\...\...\...\...: \|splitjoin-vimscript\|
     YAML\...\...\...\...\...\...\...\...\...\...\.....: \|splitjoin-yaml\|
     
     Settings\...\...\...\...\...\...\...\...\...\....: \|splitjoin-settings\|
     Internals\...\...\...\...\...\...\...\...\...\...: \|splitjoin-internals\|
     Issues\...\...\...\...\...\...\...\...\...\...\...: \|splitjoin-issues\|
     
     
     ==============================================================================
     INSTALLATION \*splitjoin-installation\*
     
     The easiest way to install the plugin is with a plugin manager:
     
     \- vim-plug: https://github.com/junegunn/vim-plug
     \- Vundle: https://github.com/VundleVim/Vundle.vim
     
     If you use one, just follow the instructions in its documentation.
     
     You can install the plugin yourself using Vim\'s \|packages\| functionality by
     cloning the project (or adding it as a submodule) under
     \`\~/.vim/pack/\<any-name\>/start/\`. For example:
     \>
     git clone https://github.com/AndrewRadev/splitjoin.vim \~/.vim/pack/\_/start/splitjoin
     \<
     This should automatically load the plugin for you on Vim start. Alternatively,
     you can add it to \`\~/.vim/pack/\<any-name\>/opt/\` instead and load it in your
     .vimrc manually with:
     \>
     packadd splitjoin
     \<
     If you\'d rather not use git, you can download the files from the \"releases\"
     tab and unzip them in the relevant directory:
     https://github.com/AndrewRadev/splitjoin.vim/releases.
     
     
     ==============================================================================
     USAGE \*splitjoin-usage\*
     
     \*:SplitjoinSplit\*
     \*:SplitjoinJoin\*
     
     After the plugin is installed, the mapping \`gS\` will perform splitting and \|gJ\|
     \-- joining of the code under the cursor. These mappings are configurable
     with \|g:splitjoin\_split\_mapping\| and \|g:splitjoin\_join\_mapping\|, respectively.
     You could also use the commands \|:SplitjoinSplit\| and \|:SplitjoinJoin\|, either
     directly, or in your own scripts.
     
     Note that \|gJ\| is a built-in mapping that is used for joining lines while
     preserving whitespace. However, if no splitting/joining is possible at this
     point, the plugin will fall back to the default mapping. If you\'d rather have
     the splitjoin mappings be no-ops in that case, you could set the mapping
     variables to empty strings, which will simply not create them at all. You can
     then make your own simple mappings by using the commands:
     \>
     let g:splitjoin\_split\_mapping = \'\'
     let g:splitjoin\_join\_mapping = \'\'
     
     nmap \<Leader\>j :SplitjoinJoin\<cr\>
     nmap \<Leader\>s :SplitjoinSplit\<cr\>
     \<
     For the record, my personal preference is to avoid mnemonics in this case and
     go for an approach that makes more sense to my fingers instead:
     \>
     nmap sj :SplitjoinSplit\<cr\>
     nmap sk :SplitjoinJoin\<cr\>
     \<
     Notice that I\'m using \"sj\" for splitting, not joining. To me, \"splitting\" a
     line results in expanding it downwards, so using \"j\" seems more intuitive,
     likewise for \"k\". The \"s\" key is ordinarily taken (try :help s), but I don\'t
     use it, so I\'ve mapped it to \<Nop\>. Your mileage may vary.
     
     Splitting \~
     
     Splitting a line consists of checking for blocks of text that the plugin knows
     how to split and, well, doing that. For example, if we have a ruby hash:
     \>
     { :one =\> \'two\', :three =\> \'four\' }
     \<
     Then, with the cursor within the hash, we can split it to get:
     \>
     {
     :one =\> \'two\',
     :three =\> \'four\'
     }
     \<
     This works for various other things, you can see some examples for each
     filetype below.
     
     If there are several different kinds of splittings that can be executed, there
     is a fixed priority. For instance, this:
     \>
     { :one =\> \'two\', :three =\> \'four\' } if foo?
     \<
     will be split into this:
     \>
     if foo?
     { :one =\> \'two\', :three =\> \'four\' }
     end
     \<
     In this case, the plugin does not take into account where exactly the cursor
     is located on the line, it just always gives priority to the if clause.
     
     For ruby hashes in particular, the cursor position is considered, however.
     Let\'s take this as an example:
     \>
     foo 1, 2, { :bar =\> :baz }, { :baz =\> :qux }
     \<
     If the cursor is located on the first hash, the result will be:
     \>
     foo 1, 2, {
     :bar =\> :baz
     }, { :baz =\> :qux }
     \<
     If it\'s on the second hash, or on any other part of the method call (like on
     \"foo\"), you\'ll get this:
     \>
     foo 1, 2, { :bar =\> :baz }, {
     :baz =\> :qux
     }
     \<
     In general, if you\'re trying to split a structure, try to \"be inside\" when you
     do so. This doesn\'t make sense in cases like the \"if\" statement, but it does
     for hashes.
     
     Joining \~
     
     Joining might impose more constraints. Take this as an example:
     \>
     if foo?
     bar
     end
     \<
     In order to turn this into:
     \>
     bar if foo?
     \<
     you need to place your cursor on the line with the \"if\" clause. If your cursor
     is on the \"bar\" line, joining will not work. This might be considered a bug (I
     find it simpler cognitively to join blocks when I\'m within them), but it
     simplifies the implementation and solves some ambiguity. This might be a nice
     example:
     \>
     if foo?
     {
     :one =\> :two,
     :three =\> :four
     }
     end
     \<
     Joining when on the line \":one =\> :two\" would currently do nothing. However,
     if we wanted to detect the type of joining we could do, we might give priority
     to the if clause instead of the hash, which would not make a lot of sense. Of
     course, with smart prioritization (or a change in implementation), it might be
     possible to get things working sensibly, but this seems to be good enough for
     now: To join the hash, be on the \"{\" line, to join the \"if\" clause (not a good
     idea, mind you, doesn\'t do anything that makes sense), be on the \"if foo?\"
     line.
     
     The basic rule of thumb here is that, to join a structure, the cursor should
     usually be at its beginning (the opening tag, the opening brace, etc.).
     
     Settings \~
     
     The plugin has many settings that implement different coding styles. It can be
     made to align dictionary items, leave or remove trailing commas, and so on.
     See \|splitjoin-settings\| for the full list.
     
     Note that all of the settings apart from mapping ones can be set as both
     global variables, and buffer-local ones. So, for instance, you could set
     \|g:splitjoin\_align\| to 0 in order to avoid aligning code in most cases, but
     set \|b:splitjoin\_align\| to 1 in your \`\~/.vim/ftplugin/ruby.vim\` file to align
     ruby code in particular. The buffer-local variables will take precedence.
     
     Now for some examples for the filetypes that have splitjoin implementations.
     
     
     ==============================================================================
     C \*splitjoin-c\*
     
     If clauses \~
     \>
     if (val1 && val2 \|\| val3);
     
     if (val1
     && val2
     \|\| val3);
     \<
     Function calls \~
     \>
     myfunction(arg1, arg2, arg3, arg4);
     
     myfunction(arg1,
     arg2,
     arg3,
     arg4);
     \<
     
     ==============================================================================
     COFFEESCRIPT \*splitjoin-coffee\*
     
     Functions \~
     \>
     (foo, bar) -\> console.log foo
     
     (foo, bar) -\>
     console.log foo
     \<
     If/unless/while/until clauses \~
     
     Since it\'s possible to join a multiline if into either a postfix or suffix
     variant, a variable controls which one it\'ll be,
     \|splitjoin\_coffee\_suffix\_if\_clause\|. By default, it\'s 1, which joins into the
     suffix format.
     \>
     console.log bar if foo?
     if foo? then console.log bar
     
     if foo?
     console.log bar
     \<
     Ternary operator \~
     
     Splitting takes into account the entire line. If the line starts with
     assignment, it tries to squeeze in the assignment part on both lines.
     
     Joining attempts to do the same process in reverse \-- if the same variable is
     being assigned to different things in both cases, that variable is moved out
     in front of the if-clause. Otherwise, it just joins the if-then-else without
     any magic.
     \>
     foo = if bar? then \'baz\' else \'qux\'
     
     if bar?
     foo = \'baz\'
     else
     foo = \'qux\'
     
     foo = if bar? then \'baz\' else \'qux\'
     \<
     Object literals \~
     \>
     one = { one: \"two\", three: \"four\" }
     
     one =
     one: \"two\"
     three: \"four\"
     \<
     Object literals in function calls \~
     
     Only splitting works this way for now, the reverse direction falls back to the
     normal object literal joining.
     \>
     foo = functionCall(one, two, three: four, five: six)
     
     foo = functionCall one, two,
     three: four
     five: six
     \<
     Multiline strings \~
     
     Note that strings are split only at the end of the line. This seems to be the
     most common case, and the restriction avoids conflicts with other kinds of
     splitting.
     \>
     foo = \"example with \#{interpolation} and \\\"nested\\\" quotes\"
     foo = \"\"\"
     example with \#{interpolation} and \"nested\" quotes
     \"\"\"
     
     bar = \'example with single quotes\'
     bar = \'\'\'
     example with single quotes
     \'\'\'
     \<
     
     ==============================================================================
     CSS \*splitjoin-css\*
     
     These also work for SCSS and LESS \-- see \|splitjoin-scss\|, \|splitjoin-less\|.
     
     Style definitions \~
     \>
     a { color: \#0000FF; text-decoration: underline; }
     
     a {
     color: \#0000FF;
     text-decoration: underline;
     }
     
     Multiline selectors \~
     \>
     h1,
     h2,
     h3 {
     font-size: 18px;
     font-weight: bold;
     }
     
     h1, h2, h3 {
     font-size: 18px;
     font-weight: bold;
     }
     \<
     
     ==============================================================================
     ELIXIR \*splitjoin-elixir\*
     
     Do-blocks \~
     \>
     def function(arguments) when condition, do: body
     def function(arguments) when condition do
     body
     end
     
     let :one, do: two() \|\> three(four())
     let :one do
     two() \|\> three(four())
     end
     
     if(foo, do: bar, else: baz)
     if foo do
     bar
     else
     baz
     end
     \<
     Comma-separated method calls (join only): \~
     \>
     for a \<- 1..10,
     Integer.is\_odd(a) do
     a
     end
     
     for a \<- 1..10, Integer.is\_odd(a) do
     a
     end
     \<
     Pipelines: \~
     \>
     String.length(\"splitjoin\")
     
     \"splitjoin\"
     \|\> String.length()
     \<
     This doesn\'t currently work properly for multi-line arguments:
     \>
     String.length(
     Enum.join(\[
     \"split\",
     \"join\"
     \])
     )
     
     if true do
     \"splitjoin\"
     end
     \|\> String.length()
     \<
     
     ==============================================================================
     ELM \*splitjoin-elm\*
     
     Lists, tuples, records \~
     \>
     myUpdatedRecord =
     {myPreviousRecord \| firstName = \"John\", lastName = \"Doe\"}
     
     myUpdatedRecord =
     { myPreviousRecord
     \| firstName = \"John\"
     , lastName = \"Doe\"
     }
     \<
     
     ==============================================================================
     ERUBY \*splitjoin-eruby\*
     
     Tags \~
     \>
     \<div class=\"foo\"\>bar\</div\>
     
     \<div class=\"foo\"\>
     bar
     \</div\>
     \<
     If/unless clauses \~
     \>
     \<%= foo if bar? %\>
     
     \<% if bar? %\>
     \<%= foo %\>
     \<% end %\>
     \<
     Hashes \~
     \>
     \<% foo = { :bar =\> \'baz\', :one =\> :two, :five =\> \'six\' } %\>
     
     \<% foo = {
     :bar =\> \'baz\',
     :one =\> :two,
     :five =\> \'six\'
     } %\>
     \<
     Option hashes \~
     \>
     \<%= link\_to \'Google\', \'http://google.com\', :class =\> \'google\', :id =\> \'google-link\' %\>
     
     \<%= link\_to \'Google\', \'http://google.com\', {
     :class =\> \'google\',
     :id =\> \'google-link\'
     } %\>
     \<
     
     ==============================================================================
     GO \*splitjoin-go\*
     
     Imports \~
     \>
     import \"fmt\"
     
     import (
     \"fmt\"
     )
     \<
     Var/const \~
     \>
     var foo string
     
     var (
     foo string
     )
     \<
     Structs \~
     \>
     StructType{one: 1, two: \"asdf\", three: \[\]int{1, 2, 3}}
     
     StructType{
     one: 1,
     two: \"asdf\",
     three: \[\]int{1, 2, 3},
     }
     \<
     
     ==============================================================================
     HAML \*splitjoin-haml\*
     
     Evaluated ruby \~
     \>
     %div= 1 + 2
     
     %div
     = 1 + 2
     \<
     
     ==============================================================================
     HANDLEBARS \*splitjoin-handlebars\*
     
     Components \~
     \>
     {{some/component-name foo=bar bar=baz}}
     
     {{some/component-name
     foo=bar
     bar=baz
     }}
     \<
     Block components \~
     \>
     {{\#component-name foo=bar}}Some content{{/component-name}}
     
     {{\#component-name foo=bar}}
     Some contents
     {{/component-name}}
     \<
     
     ==============================================================================
     HTML \*splitjoin-html\*
     
     This works for other HTML-like languages as well: XML, Eruby, JSX, TSX, Vue
     templates, Svelte.js, Django templates.
     
     Tags \~
     \>
     \<div class=\"foo\"\>bar\</div\>
     
     \<div class=\"foo\"\>
     bar
     \</div\>
     \<
     Attributes \~
     \>
     \<button class=\"foo bar\" ng-click=\"click()\" ng-class=\"{ clicked: clicked }\"\>
     Click me!
     \</button\>
     
     \<button
     class=\"foo bar\"
     ng-click=\"click()\"
     ng-class=\"{ clicked: clicked }\"\>
     Click me!
     \</button\>
     \<
     
     ==============================================================================
     JAVA \*splitjoin-java\*
     
     If-clause bodies \~
     \>
     if (isTrue())
     doSomething();
     
     if (isTrue()) doSomething();
     
     if (isTrue()) {
     doSomething();
     }
     
     if (isTrue()) { doSomething(); }
     \<
     If-clause conditions \~
     \>
     if (val1 && val2 \|\| val3)
     body();
     
     if (val1
     && val2
     \|\| val3)
     body();
     \<
     Function calls \~
     \>
     myfunction(arg1, arg2, arg3, arg4);
     
     myfunction(arg1,
     arg2,
     arg3,
     arg4);
     \<
     Lambda functions \~
     \>
     some\_function(foo -\> \"bar\");
     
     some\_function(foo -\> {
     return \"bar\";
     });
     \<
     
     ==============================================================================
     JAVASCRIPT \*splitjoin-javascript\*
     \*splitjoin-json\*
     
     Object and Array splitting also work for JSON, if it\'s set as a separate
     filetype. (If it\'s just set to \"javascript\", it\'ll just apply javascript
     logic). If the filetype is \"json\", trailing commas will automatically be
     disabled, too.
     
     Objects \~
     
     Just like in ruby and python, the cursor needs to be inside the object in
     order to split it.
     \>
     var one = {one: \"two\", three: \"four\"};
     
     var one = {
     one: \"two\",
     three: \"four\"
     };
     \<
     Arrays \~
     \>
     var one = \[\'two\', \'three\', \'four\'\];
     
     var one = \[
     \'two\',
     \'three\',
     \'four\'
     \];
     
     Function Arguments \~
     \>
     var foo = bar(\'one\', \'two\', \'three\');
     
     var foo = bar(
     \'one\',
     \'two\',
     \'three\'
     );
     \<
     Functions \~
     
     When the cursor is on the \"function\" keyword, the script attempts to split the
     curly braces of the function. This is a bit more convenient for the common
     use-case of one-line to multi-line functions.
     \>
     var callback = function (something, other) { something\_else; };
     
     var callback = function (something, other) {
     something\_else;
     };
     \<
     One-line if conditionals \~
     \>
     if (isTrue()) {
     doSomething();
     }
     
     if (isTrue()) doSomething();
     \<
     Fat-arrow functions \~
     \>
     some\_function(foo =\> \"bar\");
     
     some\_function(foo =\> {
     return \"bar\";
     });
     \<
     
     ==============================================================================
     JSX \*splitjoin-jsx\*
     \*splitjoin-tsx\*
     
     Both HTML and Javascript splitters and joiners work for JSX and TSX. There\'s
     also one additional transformation:
     
     Self-closing tags \~
     \>
     let button = \<Button /\>;
     
     let button = \<Button\>
     \</Button\>;
     
     
     Note that, in Vim, these languages are supported within the \`javascrptreact\`
     and \`typescriptreact\` filetypes, so if callbacks don\'t work right,
     double-check the detected filetype of the buffer.
     
     ==============================================================================
     LUA \*splitjoin-lua\*
     
     For Lua, only splitting and joining functions is implemented at this point.
     Note that joining a function attempts to connect the lines of the body by
     using \";\". This doesn\'t always work \-- a few constructs are not syntactically
     valid if joined in this way. Still, the idea is to inline small functions, so
     it\'s assumed this is not a big issue.
     
     Functions \~
     \>
     function example ()
     print(\"foo\")
     print(\"bar\")
     end
     
     function example () print(\"foo\"); print(\"bar\") end
     
     local something = other(function (one, two)
     print(\"foo\")
     end)
     
     local something = other(function (one, two) print(\"foo\") end)
     \<
     
     ==============================================================================
     PERL \*splitjoin-perl\*
     
     If/unless/while/until clauses \~
     
     The variable \|splitjoin\_perl\_brace\_on\_same\_line\| controls the format of the
     curly braces when joining. If it\'s set to 0, the opening curly brace will be
     on its own line. Otherwise, it\'ll be placed on the same line as the if-clause
     (the default behaviour).
     \>
     print \"a = \$a\\n\" if \$debug;
     
     if (\$debug) {
     print \"a = \$a\\n\";
     }
     \<
     And/or clauses \~
     
     It only makes sense to split these \-- joining results in joining an if/unless
     clause. The variable \|splitjoin\_perl\_brace\_on\_same\_line\| affects the results
     as explained above.
     \>
     open PID, \"\>\", \$pidfile or die;
     
     unless (open PID, \"\>\", \$pidfile) {
     die;
     }
     \<
     Hashes \~
     \>
     my \$info = {name =\> \$name, age =\> \$age};
     
     my \$info = {
     name =\> \$name,
     age =\> \$age,
     };
     \<
     Lists \~
     \>
     my \$var = \[\'one\', \'two\', \'three\'\];
     
     my \$var = \[
     \'one\',
     \'two\',
     \'three\'
     \];
     
     my \@var = (\'one\', \'two\', \'three\');
     
     my \@var = (
     \'one\',
     \'two\',
     \'three\'
     );
     \<
     Word lists \~
     \>
     my \@var = qw(one two three);
     
     my \@var = qw(
     one
     two
     three
     );
     \<
     
     ==============================================================================
     PHP \*splitjoin-php\*
     
     Arrays \~
     \>
     foo = array(\'one\' =\> \'two\', \'two\' =\> \'three\')
     
     foo = array(
     \'one\' =\> \'two\',
     \'two\' =\> \'three\'
     )
     \<
     Short arrays \~
     \>
     \$one = \[\'two\', \'three\', \'four\'\]
     
     \$one = \[
     \'two\',
     \'three\',
     \'four\'
     \]
     \<
     If-clauses \~
     \>
     if (\$foo) { \$a = \"bar\"; }
     
     if (\$foo) {
     \$a = \"bar\";
     }
     \<
     PHP markers \~
     \>
     \<?php echo \"OK\"; ?\>
     
     \<?php
     echo \"OK\";
     ?\>
     \<
     Method calls\~
     
     Affects all the arrows after the cursor when \|splitjoin\_php\_method\_chain\_full\|
     is set to 1. Otherwise, it affects only a single arrow (the default
     behaviour).
     \>
     \$var = \$one-\>two-\>three()-\>four();
     
     \$var = \$one
     -\>two-\>three()-\>four();
     
     \# OR
     
     \$var = \$one
     -\>two
     -\>three()
     -\>four();
     
     
     ==============================================================================
     PYTHON \*splitjoin-python\*
     
     Just like in ruby, the cursor needs to be inside the dict in order to split it
     correctly, otherwise it tries to split it as a statement (which works, due to
     the dict having \":\" characters in it).
     
     Dicts \~
     \>
     knights = {\'gallahad\': \'the pure\', \'robin\': \'the brave\'}
     
     knights = {
     \'gallahad\': \'the pure\',
     \'robin\': \'the brave\'
     }
     \<
     Lists \~
     \>
     spam = \[1, 2, 3\]
     
     spam = \[1,
     2,
     3\]
     \<
     Tuples \~
     \>
     spam = (1, 2, 3)
     
     spam = (1,
     2,
     3\)
     \<
     Statements \~
     \>
     if foo: bar()
     
     if foo:
     bar()
     \<
     Imports \~
     \>
     from foo import bar, baz
     
     from foo import bar,\\
     baz
     \<
     Assignment \~
     \>
     a, b = foo(\"bar\"), \[one, two, three\]
     
     a = foo(\"bar\")
     b = \[one, two, three\]
     
     un, pack = something
     
     un = something\[0\]
     pack = something\[1\]
     \<
     Note that splitting \`a, b = b, a\` would not result in an expression that works
     the same way, due to the special handling by python of this case to swap two
     values.
     
     ==============================================================================
     R \*splitjoin-r\*
     
     Function calls \~
     \>
     print(1, 2, 3)
     
     \# with g:r\_indent\_align\_args = 0
     print(
     1,
     2,
     3
     )
     
     \# with g:r\_indent\_align\_args = 1
     print(1,
     2,
     3\)
     \<
     
     ==============================================================================
     RUBY \*splitjoin-ruby\*
     
     If/unless/while/until clauses \~
     
     Joining works for more-than-one-line \"if\" clauses as well, but it doesn\'t look
     very pretty. It\'s generally recommended to use it only when the body is a
     single line.
     \>
     return \"the answer\" if 6 \* 9 == 42
     
     if 6 \* 9 == 42
     return \"the answer\"
     end
     \<
     Hashes \~
     
     To split a hash, you need to be within the curly brackets. Otherwise, the
     plugin attempts to split it as a block.
     \>
     foo = { :bar =\> \'baz\', :one =\> \'two\' }
     
     foo = {
     :bar =\> \'baz\',
     :one =\> \'two\'
     }
     \<
     Option hashes \~
     
     There\'s an option, \|splitjoin\_ruby\_curly\_braces\|, that controls whether the
     curly braces are present after splitting or joining.
     \>
     foo 1, 2, :one =\> 1, :two =\> 2
     
     foo 1, 2, {
     :one =\> 1,
     :two =\> 2
     }
     
     \# note that after joining, the result will be:
     
     foo 1, 2, { :one =\> 1, :two =\> 2 }
     \<
     Method arguments \~
     
     These only get split if there is no option hash at the end.
     
     The variable \|splitjoin\_ruby\_hanging\_args\| controls whether the arguments
     will be left \"hanging\", aligned near the brackets, or if the brackets will be
     put on their own lines.
     
     Joining for the \"hanging\" style doesn\'t really work, since there\'s no easy,
     reliable way to detect the continued arguments. However, a simple vanilla-vim
     \|J\| should do the trick.
     \>
     params.permit(:title, :action, :subject\_type, :subject\_id, :own)
     
     params.permit(:title,
     :action,
     :subject\_type,
     :subject\_id,
     :own)
     
     \# with splitjoin\_ruby\_hanging\_args == 0
     
     params.permit(
     :title,
     :action,
     :subject\_type,
     :subject\_id,
     :own
     )
     \<
     Caching constructs \~
     \>
     \@two \|\|= 1 + 1
     
     \@two \|\|= begin
     1 + 1
     end
     \<
     Blocks \~
     \>
     Bar.new { \|b\| puts b.to\_s }
     
     Bar.new do \|b\|
     puts b.to\_s
     end
     \<
     Block &-shorthand \~
     \>
     \[1, 2, 3\].map(&:to\_s)
     
     \[1, 2, 3\].map do \|i\|
     i.to\_s
     end
     \<
     Heredocs \~
     
     You can change whether it splits into \`\<\<\`, \`\<\<-\`, or \`\<\<\~\` by setting the
     value of the \|splitjoin\_ruby\_heredoc\_type\| setting (by default, it\'s \`\<\<\~\`).
     \>
     string = \'something\'
     
     string = \<\<\~EOF
     something
     EOF
     \<
     Ternaries \~
     \>
     if condition
     do\_foo
     else
     do\_bar
     end
     
     condition ? do\_foo : do\_bar
     \<
     Cases \~
     
     Splits or joins single when clauses, if the cursors sits on the line of
     such a when, or the whole case, if you have or cursor in the line of the
     case-keyword, as shown in the example.
     \>
     case condition
     when :a
     do\_foo
     when :b
     do\_bar
     else
     do\_baz
     end
     
     case condition
     when :a then do\_foo
     when :b then do\_bar
     else do\_baz
     end
     \>
     Arrays \~
     \>
     list = \[\'one\', \'two\', \'three\'\]
     
     list = \[
     \'one\',
     \'two\',
     \'three\'
     \]
     \<
     Array literals \~
     \>
     list = %w{one two three}
     
     list = %w{
     one
     two
     three
     }
     \<
     Module namespacing \~
     
     Note that splitting and joining module namespaces relies on the built-in
     \|matchit\| plugin. Splitjoin will attempt to load it if it isn\'t loaded
     already, but if that fails for some reason, this logic will silently not work.
     \>
     module Foo
     class Bar \< Baz
     def qux
     end
     end
     end
     
     class Foo::Bar \< Baz
     def qux
     end
     end
     \<
     Module namespacing in RSpec tests \~
     
     Same as above: uses the \|matchit\| plugin.
     \>
     module Foo
     RSpec.describe Bar do
     it \"does stuff\" do
     end
     end
     end
     
     RSpec.describe Foo::Bar do
     it \"does stuff\" do
     end
     end
     \<
     Method continuations \~
     
     For the moment, this only works in the direction of joining, since splitting
     is too ambiguous (how to decide whether to split the method dot or the
     function\'s arguments?).
     \>
     one.
     two.three(foo, bar)
     one
     .two.three(foo, bar)
     
     one.two.three(foo, bar)
     
     Ruby 3.0 endless def \~
     \>
     def foo(one, two)
     bar
     end
     
     def foo(one, two) = bar
     \<
     
     ==============================================================================
     RUST \*splitjoin-rust\*
     
     Structs \~
     \>
     Scanner { source: String::new(), line: 1 }
     
     Scanner {
     source: String::new(),
     line: 1
     }
     \<
     Match clauses \~
     \>
     match one {
     Ok(two) =\> some\_expression(three),
     }
     
     match one {
     Ok(two) =\> {
     some\_expression(three)
     },
     }
     \<
     Question mark operator \~
     
     The plugin determines how to split a \`?\` by looking upwards for a \`-\> Result\`
     or \`-\> Option\` . If it can\'t find anything when splitting, it\'ll default to a
     \`Result\`. If it can\'t find anything when joining, it\'ll convert the match into
     an \`.unwrap()\` instead.
     \>
     let file = File::open(\"foo.txt\")?;
     
     let file = match File::open(\"foo.txt\") {
     Ok(value) =\> value,
     Err(e) =\> return Err(e.into()),
     };
     
     let thing = Some(3)?;
     
     let thing = match Some(3) {
     None =\> return None,
     Some(value) =\> value,
     };
     \<
     Closures \~
     \>
     function\_call(\|x\| x.to\_string(), y);
     
     function\_call(\|x\| {
     x.to\_string()
     }, y);
     \<
     Unwrap/Expect match split \~
     
     This one only splits for the moment. The cursor MUST be on \`unwrap\` in order
     to get this effect, in this particular example.
     
     The plugin attempts to find the end of the expression, and make a match
     statement out of it. It also works with \`expect\` calls.
     \>
     let foo = Some::value(chain).of(things).unwrap();
     
     let foo = match Some::value(chain).of(things) {
     
     }
     \<
     Empty matches and if-let \~
     \>
     if let Some(value) = iterator.next() {
     println!(\"do something with {}\", value);
     }
     
     match iterator.next() {
     Some(value) =\> {
     println!(\"do something with {}\", value);
     },
     \_ =\> (),
     }
     \<
     Import lists \~
     
     With the cursor on the pre-curly bracket part of an import:
     \>
     use std::io::{Read, Write, Process};
     
     use std::io::Read;
     use std::io::Write;
     use std::io::Process;
     \<
     Joining works downwards \-- attempting to join the current line with as many as
     possible below. It will look for the common part between the first two imports
     and try to apply it on any later ones that match.
     
     With the cursor in the curly brackets:
     \>
     use std::io::{Read, Write};
     
     use std::io::{
     Read,
     Write
     };
     \<
     
     ==============================================================================
     SCSS \*splitjoin-scss\*
     LESS \*splitjoin-less\*
     
     Everything that works for CSS should work as well, and there\'s extra
     functionality for the added nesting possibility.
     
     Nested definitions \~
     
     When splitting, the cursor position determines which part gets extracted into
     a separate definition. Joining only works if there\'s only one child definition.
     \>
     ul li {
     a {
     padding: 10px;
     }
     }
     
     ul li a {
     padding: 10px;
     }
     \<
     
     ==============================================================================
     SHELL \*splitjoin-shell\*
     
     Support for shell scripts is quite basic \-- splitting and joining by
     semicolon. That\'s why it should be compatible with Bash, ZSH, etc. Activates
     for the \`sh\` and \`zsh\` filetypes.
     \>
     echo \"one\"; echo \"two\"
     
     echo \"one\"
     echo \"two\"
     \<
     
     ==============================================================================
     TEX \*splitjoin-tex\*
     
     Begin-end blocks \~
     \>
     \\begin{align\*} x = y\\\\ y = z \\end{align\*}
     
     \\begin{align\*}
     x = y\\\\
     y = z
     \\end{align\*}
     \<
     Enumerations \~
     \>
     \\begin{enumerate} \\item item1 \\item item2 \\end{enumerate}
     
     \\begin{enumerate}
     \\item item1
     \\item item2
     \\end{enumerate}
     \<
     
     ==============================================================================
     VIMSCRIPT \*splitjoin-vimscript\*
     
     Vimscript can generally be split anywhere by simply placing the remainder of
     the line on the next one, prefixed by a backslash. That\'s why joining is
     fairly easy to do for the most general case \-- anything that is followed by a
     line, starting with a backslash, can be joined with the current one.
     \>
     let example\_one = {
     \\ \'one\': \'two\',
     \\ \'three\': \'four\'
     \\ }
     
     \" is joined (one line at a time) into:
     
     let example\_one = { \'one\': \'two\', \'three\': \'four\' }
     
     command! Foo if one \|
     \\ \'two\' \|
     \\ else \|
     \\ \'three\' \|
     \\ endif
     
     \" is joined (one line at a time) into:
     
     command! Foo if one \| \'two\' \| else \| \'three\' \| endif
     \<
     Splitting is a bit trickier, since anything can be split at any point. While
     it\'s possible to handle some specific cases like dictionaries, arrays, and
     commands, for now the plugin takes the simple approach of splitting precisely
     where the cursor is right now. In the future, this may be replaced with
     specific splits based on the context.
     
     
     ==============================================================================
     YAML \*splitjoin-yaml\*
     
     Arrays \~
     \>
     root:
     one: \[1, 2\]
     two: \[\'three\', \'four\'\]
     
     root:
     one:
     \- 1
     \- 2
     two:
     \- \'three\'
     \- \'four\'
     \<
     Maps \~
     \>
     root:
     one: { foo: bar }
     two: { three: \[\'four\', \'five\'\], six: seven }
     
     root:
     one:
     foo: bar
     two:
     three: \[\'four\', \'five\'\]
     six: seven
     \<
     
     ==============================================================================
     SETTINGS \*splitjoin-settings\*
     
     These are the variables that control the behaviour of the plugin.
     
     Check the tags on the right side. The ones starting with \`g:\` are global
     settings, while the ones starting with \`b:\` are buffer-local. The settings
     that don\'t start with either of these two exist in both forms \-- you can have
     one global value for the setting and different buffer-local ones.
     
     
     \*b:splitjoin\_split\_callbacks\*
     \*b:splitjoin\_join\_callbacks\*
     \>
     let b:splitjoin\_split\_callbacks = \[\...\]
     let b:splitjoin\_join\_callbacks = \[\...\]
     \<
     Default value: depends on the filetype
     
     These two variables contain lists of functions that are called to execute the
     splitting or joining functionality. If they are set to an empty array in a
     particular file, this will effectively disable the plugin for it. You can look
     through the source code of the plugin to see the functions that are currently
     being executed for your filetype.
     
     Example:
     Putting the following in ftplugin/ruby.vim will disable the join functionality
     for ruby files:
     \>
     let b:splitjoin\_join\_callbacks = \[\]
     \<
     
     
     \*g:splitjoin\_split\_mapping\*
     \*g:splitjoin\_join\_mapping\*
     \>
     let g:splitjoin\_split\_mapping = \'cS\'
     let g:splitjoin\_join\_mapping = \'cJ\'
     \<
     
     Default values: \'gS\' and \'gJ\'
     
     Changing these values changes the default mappings of the plugin. Note that,
     if no splitting or joining can be performed, these default mappings will fall
     back to performing the key sequence\'s built-in functionality.
     
     Set to a blank string to disable default mappings completely. You can still
     create your own mapping the old-fashioned way using the \|:SplitjoinSplit\| and
     \|:SplitjoinJoin\| commands, though in the case with no possible
     splitting/joining, nothing will happen.
     
     
     \*splitjoin\_quiet\*
     \>
     let g:splitjoin\_quiet = 1
     \<
     Default value: 0
     
     The plugin will output a message, \"Splitjoin: Working\...\", when splitting or
     joining, which will be cleared when it\'s done. Ideally, this will only show up
     for a fraction of a second, but with very large code blocks, there might be
     work to do. A regrettable example is splitting a large ruby hash \-- the plugin
     itself doesn\'t do a lot of work, but indentation ends up rather slow in this
     particular scenario.
     
     In order to silence these messages, if you find them annoying, set this
     variable to 1.
     
     \*splitjoin\_disabled\_split\_callbacks\*
     \>
     let g:splitjoin\_disabled\_split\_callbacks = \[\'sj\#html\#SplitAttributes\'\]
     \<
     Default value: \[\]
     
     This setting allows you to disable a particular split type by adding its
     function callback to the list. To find the specific name to disable, you\'d
     need to dig into the source code of the plugin in
     \`ftplugin/\<filetype-name\>/splitjoin.vim\`. If you\'re not sure which callback
     performs which split, try disabling them one by one until you\'ve got the
     behaviour you\'re looking for.
     
     \*splitjoin\_disabled\_join\_callbacks\*
     \>
     let g:splitjoin\_disabled\_join\_callbacks = \[\'sj\#html\#JoinAttributes\'\]
     \<
     Default value: \[\]
     
     This setting allows you to disable a particular join type by adding its
     function callback to the list. To find the specific name to disable, you\'d
     need to dig into the source code of the plugin in
     \`ftplugin/\<filetype-name\>/splitjoin.vim\`. If you\'re not sure which callback
     performs which join, try disabling them one by one until you\'ve got the
     behaviour you\'re looking for.
     
     \*splitjoin\_normalize\_whitespace\*
     \>
     let g:splitjoin\_normalize\_whitespace = 0
     \<
     Default value: 1
     
     This variable controls whether duplicate whitespace should be reduced within a
     joined structure, which makes a lot of sense in most situations, particularly
     when the items are aligned. Set it to 0 to disable this behaviour.
     
     Example:
     When this setting is enabled, the extra whitespace around \"=\>\" symbols in ruby
     hashes is removed:
     \>
     one = {
     :one =\> \'two\',
     :three =\> \'four\',
     :a =\> \'b\'
     }
     
     one = { :one =\> \'two\', :three =\> \'four\', :a =\> \'b\' }
     \<
     
     \*splitjoin\_align\*
     \>
     let g:splitjoin\_align = 1
     \<
     Default value: 0
     
     This is a flag that controls whether a few constructs should be aligned by a
     certain character. As a specific example, when you split ruby hashes, this can
     align them by the \"=\>\" signs. In a way, \|splitjoin\_normalize\_whitespace\| is
     a complement to this setting, since you\'d probably want to reduce the extra
     whitespace when joining.
     
     Set the flag to 1 to attempt alignment. In order for it to work, it requires
     that you have either Tabular (https://github.com/godlygeek/tabular) or Align
     (http://www.vim.org/scripts/script.php?script\_id=294) installed. If that\'s not
     the case, the value of this setting will be ignored.
     
     Example:
     \>
     one = { :one =\> \'two\', :three =\> \'four\', :a =\> \'b\' }
     
     one = {
     :one =\> \'two\',
     :three =\> \'four\',
     :a =\> \'b\'
     }
     \<
     
     \*splitjoin\_curly\_brace\_padding\*
     \>
     let g:splitjoin\_curly\_brace\_padding = 0
     \<
     Default value: 1
     
     Controls whether joining things with curly braces will add a space between the
     brackets and the joined body. So, setting it to 0 or 1 results in, respectively:
     \>
     import {one, two, three} from \'foo\';
     import { one, two, three } from \'foo\';
     \<
     
     
     \*splitjoin\_trailing\_comma\*
     \>
     let g:splitjoin\_trailing\_comma = 1
     \<
     Default value: 0
     
     This adds a trailing comma when splitting lists of things. There is a
     ruby-specific setting called \|splitjoin\_ruby\_trailing\_comma\|, but it\'s
     preferred to use this one. You can easily set it per-filetype by using the
     buffer-local variable with the same name.
     
     Example:
     \>
     one = { :one =\> \'two\', :a =\> \'b\' }
     
     one = {
     :one =\> \'two\',
     :a =\> \'b\',
     }
     \<
     
     \*splitjoin\_ruby\_curly\_braces\*
     \>
     let g:splitjoin\_ruby\_curly\_braces = 0
     \<
     Default value: 1
     
     This flag controls the formatting of ruby option hashes when splitting.
     When it\'s 1, curly braces will be present in option blocks. Example:
     \>
     User.new :one, :first\_name =\> \"Andrew\", :last\_name =\> \"Radev\"
     
     User.new :one, {
     :first\_name =\> \"Andrew\",
     :last\_name =\> \"Radev\"
     }
     \<
     When the flag is 0, the result will be:
     \>
     User.new :one,
     :first\_name =\> \"Andrew\",
     :last\_name =\> \"Radev\"
     \<
     This won\'t always have effect. In some cases, it\'s not syntactically valid to
     omit the curly braces, which is part of the reason I prefer having them
     around. However, when there\'s a non-optional argument or the option hashes is
     wrapped in round braces, it should work just fine.
     
     Regardless of the value of this option, the second example will be joined back
     to:
     \>
     User.new :one, :first\_name =\> \"Andrew\", :last\_name =\> \"Radev\"
     \<
     That\'s because it\'s easy to infer that it\'s an option block. Unfortunately,
     it\'s more difficult to decide whether we have an option block or a plain hash
     if there are braces, so the first example will always be joined to:
     \>
     User.new :one, { :first\_name =\> \"Andrew\", :last\_name =\> \"Radev\" }
     \<
     
     \*splitjoin\_ruby\_trailing\_comma\*
     \>
     let g:splitjoin\_ruby\_trailing\_comma = 1
     \<
     Default value: 0
     
     This controls whether to put a trailing comma on a split hash. With this set
     to 1, a hash will split like so:
     \>
     User.new :one, :first\_name =\> \"Andrew\", :last\_name =\> \"Radev\"
     
     User.new :one, {
     :first\_name =\> \"Andrew\",
     :last\_name =\> \"Radev\",
     }
     \<
     Note the trailing comma for the last element.
     
     It\'s preferred to use the global option \|splitjoin\_trailing\_comma\|, and set the
     buffer-local one for ruby to something different, if you\'d like to.
     
     
     \*splitjoin\_ruby\_hanging\_args\*
     \>
     let g:splitjoin\_ruby\_hanging\_args = 0
     \<
     Default value: 1
     
     This controls whether to split function arguments in the \"hanging\" style:
     \>
     params.permit(:title,
     :action,
     :subject)
     \<
     If it is set to 0, the result will be:
     \>
     params.permit(
     :title,
     :action,
     :subject
     )
     \<
     
     \*splitjoin\_ruby\_do\_block\_split\*
     \>
     g:splitjoin\_ruby\_do\_block\_split
     \<
     Default value: 1
     
     This controls whether to convert split blocks to their do-form. It\'s set to
     \"1\" by default, so block split like so:
     \>
     \[1, 2, 3\].map { \|n\| n \*\* 2 }
     
     \[1, 2, 3\].map do \|n\|
     n \*\* 2
     end
     \<
     If it is set to 0, the result will be:
     \>
     \[1, 2, 3\].map { \|n\| n \*\* 2 }
     
     \[1, 2, 3\].map { \|n\|
     n \*\* 2
     }
     \<
     
     \*splitjoin\_ruby\_options\_as\_arguments\*
     \>
     let g:splitjoin\_ruby\_options\_as\_arguments = 1
     \<
     Default value: 0
     
     If set to 1, this will split options along with arguments, except if the
     cursor is on one of the options.
     
     Ordinarily, splitting function arguments will always split options, if there
     are any, and only split positional arguments, if there are no options. Like in
     this example:
     \>
     User.new(:one, :two, first\_name: \"Andrew\", last\_name: \"Radev\")
     
     User.new(:one, :two,
     first\_name: \"Andrew\",
     last\_name: \"Radev\")
     \<
     With this option set to 1, the plugin will split BOTH arguments and options,
     if the cursor is on the arguments, and it will split ONLY options if the
     cursor is on the options.
     
     So, with the cursor on \"two\":
     \>
     User.new(:one,
     :two,
     first\_name: \"Andrew\",
     last\_name: \"Radev\")
     \<
     But with the cursor on \"first\_name\", you\'ll still get:
     \>
     User.new(:one, :two,
     first\_name: \"Andrew\",
     last\_name: \"Radev\")
     \<
     The output varies according to other settings as well, like curly brackets.
     
     
     \*splitjoin\_coffee\_suffix\_if\_clause\*
     \>
     let g:splitjoin\_coffee\_suffix\_if\_clause = 0
     \<
     
     Default value: 1
     
     This flag controls the kind of if-clause to use when joining multiline
     if-clauses in coffeescript. Given the following example:
     \>
     if foo?
     console.log bar
     \<
     Joining this construct with \|splitjoin\_coffee\_suffix\_if\_clause\| set to 1 (the
     default) would produce:
     \>
     console.log bar if foo?
     \<
     Doing that with \|splitjoin\_coffee\_suffix\_if\_clause\| set to 0 would result in:
     \>
     if foo? then console.log bar
     \<
     
     \*splitjoin\_perl\_brace\_on\_same\_line\*
     \>
     let g:splitjoin\_perl\_brace\_on\_same\_line = 0
     \<
     Default value: 1
     
     This flag controls the placement of curly braces when joining if-clauses. When
     it\'s 1 (the default), the opening brace will be placed on the same line:
     \>
     if (\$debug) {
     print \"a = \$a\\n\";
     }
     \<
     If it\'s set to 0, the brace will get its own line:
     \>
     if (\$debug)
     {
     print \"a = \$a\\n\";
     }
     \<
     
     \*splitjoin\_ruby\_heredoc\_type\*
     \>
     let g:splitjoin\_ruby\_heredoc\_type = \'\<\<-\'
     \<
     Default value: \"\<\<\~\"
     
     This setting can be one of \"\<\<-\", \"\<\<\~\", and \"\<\<\" and controls how strings
     will be split into heredocs. If it\'s \"\<\<-\", the following form is used
     \>
     do
     foo = \<\<-EOF
     something
     EOF
     end
     \<
     If it\'s set to \"\<\<\", the result is this:
     \>
     do
     foo = \<\<EOF
     something
     EOF
     end
     \<
     With \"\<\<\~\" (the default), you\'ll get:
     \>
     do
     foo = \<\<\~EOF
     something
     EOF
     end
     \<
     
     \*splitjoin\_python\_brackets\_on\_separate\_lines\*
     \>
     let g:splitjoin\_python\_brackets\_on\_separate\_lines = 1
     \<
     Default value: 0
     
     If set to 1, then python will split lists and tuples so that the opening and
     closing bracket are placed on separate lines. If it\'s 0, the first argument
     will remain where it is, and the rest will be split on separate lines.
     
     Example:
     \>
     \# let g:splitjoin\_python\_brackets\_on\_separate\_lines = 1
     some\_method(
     one,
     two
     )
     
     \# let g:splitjoin\_python\_brackets\_on\_separate\_lines = 0
     some\_method(one,
     two)
     \<
     The first example might look a bit odd, but if you have the python-pep8-indent
     plugin (https://github.com/hynek/vim-python-pep8-indent), it should look quite
     reasonable.
     
     
     \*splitjoin\_handlebars\_closing\_bracket\_on\_same\_line\*
     \>
     let g:splitjoin\_handlebars\_closing\_bracket\_on\_same\_line = 1
     \<
     Default value: 0
     
     If set to 1, then handlebars will keep the closing \"}}\" on the same line as
     the last line of the component. At the time of writing, this isn\'t indented
     very well, but it might be improved in the future.
     
     If it\'s 0, the closing \"}}\" will be placed on its own line.
     
     
     \*splitjoin\_handlebars\_hanging\_arguments\*
     \>
     let g:splitjoin\_handlebars\_hanging\_arguments = 1
     \<
     Default value: 0
     
     If set to 1, then handlebars will keep one argument on the first line when
     splitting, so the component will look \"hanging\". With the closing bracket on
     the same line, as above, and the right indentation plugin, it might look like
     this:
     \>
     {{foo-bar one=\"two\"
     three=\"four\"}}
     \<
     If it\'s 0, the default, all parameters will be on their own line:
     \>
     {{foo-bar
     one=\"two\"
     three=\"four\"}}
     \<
     
     \*splitjoin\_html\_attributes\_bracket\_on\_new\_line\*
     \>
     let g:splitjoin\_html\_attributes\_bracket\_on\_new\_line = 1
     \<
     Default value: 0
     
     If set to 1, then splitting HTML attributes will put the closing angle bracket
     on a new line on its own, like this:
     \>
     \<div
     class=\"whatever\"
     \>
     text
     \</div\>
     \<
     When set to 0, as is the default, it will look like this:
     \>
     \<div
     class=\"whatever\"\>
     text
     \</div\>
     \<
     \*splitjoin\_html\_attributes\_hanging\*
     \>
     let g:splitjoin\_html\_attributes\_hanging = 1
     \<
     Default value: 0
     
     If set to 1, then splitting HTML attributes will keep the first attribute on
     the same line, and split the rest. Combined with indentation support, it
     should look like this:
     \>
     \<button class=\"button control\"
     \@click=\"save\"
     v-if=\"admin\"\>
     Save
     \</button\>
     \<
     When set to 0, as is the default, it will look like this:
     \>
     \<button
     class=\"button control\"
     \@click=\"save\"
     v-if=\"admin\"\>
     Save
     \</button\>
     \<
     
     \*splitjoin\_php\_method\_chain\_full\*
     \>
     let g:splitjoin\_php\_method\_chain\_full = 1
     \<
     Default value: 0
     
     If set to 1, then splitting a method chain will split all the arrows after the
     cursor.
     \>
     \$var = \$foo-\>one()-\>two()-\>three();
     
     Splitting on \"-\>two\" if set to 0:
     \>
     \$var = \$foo-\>one()
     -\>two()-\>three();
     
     If set to 1:
     \>
     \$var = \$foo-\>one()
     -\>two()
     -\>three();
     
     Joining a chain will also join all the methods calls.
     
     \*splitjoin\_java\_argument\_split\_first\_newline\*
     \*splitjoin\_java\_argument\_split\_last\_newline\*
     \>
     let g:splitjoin\_java\_argument\_split\_first\_newline = 1
     let g:splitjoin\_java\_argument\_split\_last\_newline = 1
     \<
     Default value: 0
     
     These variables control whether a newline will be placed between the bracket
     and the first or last item of a java argument list when splitting. With the
     default, both set to 0, a split might look like this:
     \>
     functionCall(one,
     two,
     three)
     \<
     With both values set to 1, a space will be left before the first item and
     after the last one:
     \>
     functionCall(
     one,
     two,
     three
     )
     \<
     This is a setting that might be generalized for other languages and constructs
     at a later time.
     
     ==============================================================================
     INTERNALS \*splitjoin-internals\*
     
     The only interface of the plugin is in \'plugin/splitjoin.vim\'. It\'s a fairly
     short file containing two commands, \|:SplitjoinSplit\| and \|:SplitjoinJoin\|. All
     of the actual splitting and joining logic is in autoloaded files. The only
     things that these two commands do are:
     
     \- Check the \|b:splitjoin\_join\_callbacks\| and \|b:splitjoin\_split\_callbacks\|
     respectively for a list of function names.
     \- Invoke the functions, in order. If any of the functions returns a number
     different than 0, stop.
     
     The actual functions may do whatever they want, but it makes sense for them to
     return 0 only if they haven\'t made any modifications to the buffer.
     
     The function names could be buffer-local, global, autoloaded, anything the
     \|function()\| call can use.
     
     Obviously, extending the plugin is straightforward \-- it\'s enough to define a
     function for splitting and one for joining and add those to the buffer
     variable. Of course, that doesn\'t imply it\'s easy \-- the functions would need
     to actually perform all the necessary manipulations and simply inform the
     plugin if they\'ve been successful by returning a number other than 0 as a
     result.
     
     The file \'autoload/sj.vim\' contains helpers that might be useful for said
     manipulations. There are functions for replacing bodies of text defined by
     normal mode motions or by line ranges, for saving and restoring the cursor
     position and possibly other interesting functions that might assist. They
     should be commented reasonably well.
     
     The other files in \'autoload/sj\' might be useful as well, although they\'re
     mostly filetype-specific.
     
     The files in \'autoload/sj/argparser\' contain small parsers for parts of a few
     of the languages that are supported. They\'re necessary for splitting
     dictionary objects, since those can have a lot of structure and usually can\'t
     be analyzed properly with just regular expressions.
     
     ==============================================================================
     ISSUES \*splitjoin-issues\*
     
     \- If \|g:splitjoin\_align\| is truthy and the Align plugin is being used, the
     \"undo\" action undoes only the alignment first, then the splitting.
     \- Joining ruby option hashes could result in a pair of unnecessary curly
     braces.
     
     Any other issues and suggestions are very welcome on the github bugtracker:
     https://github.com/AndrewRadev/splitjoin.vim/issues
     
     
     vim:tw=78:sw=4:ft=help:norl:
  -- -----------------------------------------------------------------------------------------------------

-   Copy lines
-   Copy permalink
-   [View git blame](/AndrewRadev/splitjoin.vim/blame/452d1359fb14731a316be49fb446a05d2c7d2f71/doc/splitjoin.txt){#js-view-git-blame .dropdown-item .js-update-url-with-hash}
-   [Reference in new issue](/AndrewRadev/splitjoin.vim/issues/new){#js-new-issue .dropdown-item}

Go

-   © 2022 GitHub, Inc.

```{=html}
<!-- -->
```
-   [Terms](https://docs.github.com/en/github/site-policy/github-terms-of-service)
-   [Privacy](https://docs.github.com/en/github/site-policy/github-privacy-statement)
-   [Security](https://github.com/security)
-   [Status](https://www.githubstatus.com/)
-   [Docs](https://docs.github.com)
-   [Contact GitHub](https://support.github.com?tags=dotcom-footer)
-   [Pricing](https://github.com/pricing)
-   [API](https://docs.github.com)
-   [Training](https://services.github.com)
-   [Blog](https://github.blog)
-   [About](https://github.com/about)

You can't perform that action at this time.

You signed in with another tab or window. [Reload]() to refresh your session.
You signed out in another tab or window. [Reload]() to refresh your session.
